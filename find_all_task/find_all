#! /bin/sh
getopts_temp=":bcdefhkprsuwLOGSRl:P:"
test_option=
test_dir=
r_option=1
l_option=1
l_file=
p_option=1
p_pattern=

# function inspects directory
# $1 - path to directory
# $2 - test option
find_directory () {
    cd "$1"
    dir_name=$(eval basename $PWD)

    printf ">dir: %s\n" "${dir_name}"
    ls -A . | while read file; do
        if test "-$2" ${file}; then
            path=$(realpath ${file})
            printf "%s\n" "${path}"
        fi
        
        # use recursion if r option set and file is directory
        if [ "${r_option}" -eq 0 ] && [ -d "${file}" ]; then
            # step into directory if not symlink, if readable and executable
            step_flag=0
            if [ -L "${file}" ]; then
                step_flag=1
                printf "DEBUG| \"%s\" is symlink\n" "${file}" >&2
            fi

            if [ ! -r "${file}" ]; then 
                step_flag=1
                printf "DEBUG| \"%s\" is not readable\n" "${file}" >&2
            fi

            if [ ! -e "${file}" ]; then
                step_flag=1
                printf "DEBUG| \"%s\" is not executable\n" "${file}" >&2
            fi

            if [ "${step_flag}" -eq 0 ]; then
                # printf "DEBUG| step into \"%s\"\n" "${file}" >&2
                find_directory "${file}" "$2"
            fi
        fi
    done

    cd ..
}

while getopts "${getopts_temp}" option;
do 
    case "${option}" in
        b|c|d|e|f|h|k|p|r|s|u|w|L|O|G|S ) 
        # check option set 
            test_option="${option}"
            ;;
        l )
            l_option=0
            l_file="${OPTARG}"
            ;;
        R ) 
            r_option=0
            ;;
        P )
            p_option=0
            p_pattern="${OPTARG}"
            ;;
        \? )
            printf "DEBUG| Incorrect option -${option}\n" >&2
            exit 1
            ;;
    esac
done
shift $(( OPTIND - 1 ))

# checking log option
if [ "${l_option}" -eq 0 ]; then 
    if [ "X${l_file}" = "X" ]; then
        l_file="logfile"
    fi

    printf "" > ${l_file}
    exec 2>> ${l_file}
fi

test_dir="$1"
date_format=$(eval "date '+%Y-%m-%d %H:%M:%S'")

printf "DEBUG| %s\nDEBUG| %s\n" "${date_format}" "$PWD" >&2
printf "%s\n" "------------------------------------------------------" >&2
printf "DEBUG| starting programming with command line parameters\n" >&2
printf "DEBUG| dir=%s\n" "${test_dir}" >&2
# checking directory set
if [ "X${test_dir}" = "X" ]; then
    test_dir="."
    printf "DEBUG| setting current directory to: %s\n" "${test_dir}" >&2
fi
# checking test option set
printf "DEBUG| option=%s\n" "${test_option}" >&2
if [ "X${test_option}" = "X" ]; then
    test_option="f"
    printf "DEBUG| setting option=%s\n" "${test_option}" >&2
fi

# checking r option
if [ "${r_option}" -eq 0 ]; then
    printf "DEBUG| option=%s\n" "r" >&2
fi

# checking p option
if [ "${p_option}" -eq 0 ]; then
    printf "DEBUG| option=%s\n" "p" >&2
    printf "DEBUG| pattern=%s\n" "${p_pattern}" >&2
fi

if [ "${l_option}" -eq 0 ]; then
    printf "DEBUG| option=%s\n" "l" >&2
    printf "DEBUG| file=%s\n" "${l_file}" >&2
fi
printf "%s\n" "------------------------------------------------------" >&2

# checking dir exists
if [ ! -d ${test_dir} ]; then
    printf "DEBUG| directory \"%s\" does not exist\nDEBUG| terminating\n" "${test_dir}" >&2
    printf "%s\n" "------------------------------------------------------" >&2
    exit 1
fi
# stepping into directory
find_directory "${test_dir}" "${test_option}"

